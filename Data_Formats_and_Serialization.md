# 데이터 교환 포맷과 직렬화 (JSON, XML, YAML)

서로 다른 시스템 간에 데이터를 주고받는 방법과, 그 과정의 핵심인 직렬화(Serialization) 및 주요 데이터 교환 포맷(JSON, XML, YAML)의 특징을 비교하여 설명한다.

---

## 1. 직렬화(Serialization)란 무엇인가?

**직렬화(Serialization)** 란, 프로그램 내부에서 사용되는 메모리 위의 **객체(Object)를, 파일로 저장하거나 네트워크를 통해 전송할 수 있는 형태(일련의 바이트 스트림 또는 텍스트)** 로 변환하는 과정을 의미한다.

- **객체 (In-Memory):** 프로그램이 실행 중일 때만 메모리에 존재하는, 복잡한 구조의 데이터 덩어리.
- **직렬화된 형태 (On-Disk/Network):** 전송이나 저장이 용이한, 순서가 있는 단순한 데이터의 나열.

쉽게 비유하자면, 컴퓨터 메모리라는 '작업 공간'에 어지럽게 놓인 여러 부품(객체)들을, 다른 곳으로 옮기기 위해 상자(파일)에 차곡차곡 순서대로 담아 포장하는 것과 같다. 이 포장하는 행위가 **직렬화**이며, 상자를 열어 다시 부품을 꺼내 조립하는 행위가 **역직렬화(Deserialization)** 이다.

### 직렬화는 왜 필요한가?

1.  **데이터 전송:** 네트워크를 통해 다른 컴퓨터나 시스템으로 객체를 보낼 때 (예: 웹 API 요청 및 응답).
2.  **데이터 저장:** 현재 프로그램의 상태나 데이터를 파일 형태로 저장하여 영속성(Persistence)을 부여할 때 (예: 설정 파일, 게임 저장 파일).
3.  **플랫폼 간 호환성:** 서로 다른 프로그래밍 언어나 아키텍처를 사용하는 시스템들이 동일한 형식의 데이터를 공유하고 이해할 수 있게 해준다.

---

## 2. 주요 데이터 교환 포맷 비교

직렬화를 통해 변환된 데이터는 특정 '포맷'을 가진다. 가장 널리 사용되는 세 가지 포맷인 JSON, XML, YAML을 비교한다.

> **비교를 위한 예시 데이터:**
>
> - 사용자 정보: 이름(John Doe), 나이(30), 활성 상태(true), 보유 기술(["Java", "Python", "SQL"])

### 가. JSON (JavaScript Object Notation)

JavaScript의 객체 표현 방식에서 유래한 포맷으로, 현재 웹 API와 비동기 통신에서 사실상의 표준으로 사용된다.

**예시:**

```json
{
  "name": "John Doe",
  "age": 30,
  "isActive": true,
  "skills": ["Java", "Python", "SQL"]
}
```

- **장점:**
  - **가벼움:** 문법 구조가 단순하여 데이터의 용량이 작고 파싱 속도가 빠르다.
  - **높은 가독성:** 사람이 읽고 이해하기 쉽다.
  - **높은 호환성:** 거의 모든 프로그래밍 언어에서 기본적으로 지원한다.
- **단점:**
  - **주석 미지원:** 공식적으로 주석을 달 수 없어, 설정 파일 등에는 부적합할 수 있다.
  - **엄격한 문법:** 키(key)를 반드시 큰따옴표(`"`)로 감싸야 하고, 마지막 요소 뒤에 쉼표(trailing comma)를 허용하지 않는 등 문법이 엄격하다.

### 나. XML (eXtensible Markup Language)

HTML처럼 태그(`<>`)를 사용하여 데이터를 계층적으로 표현하는 마크업 언어입니다. 과거 웹 서비스(SOAP API)에서 널리 사용되었으며, 복잡한 문서나 스키마 정의가 필요할 때 여전히 사용된다.

**예시:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<user>
  <name>John Doe</name>
  <age>30</age>
  <isActive>true</isActive>
  <skills>
    <skill>Java</skill>
    <skill>Python</skill>
    <skill>SQL</skill>
  </skills>
</user>
```

- **장점:**
  - **높은 확장성:** 스키마(DTD, XSD)를 통해 데이터 구조를 사전에 정의하고 검증할 수 있다.
  - **주석 및 네임스페이스 지원:** 주석을 지원하며, 태그 이름의 충돌을 막는 네임스페이스 기능을 제공한다.
  - **데이터와 표현의 분리:** 데이터의 의미를 태그로 명확하게 설명할 수 있다.
- **단점:**
  - **장황함(Verbose):** 여는 태그와 닫는 태그가 항상 필요하여 데이터 크기가 JSON에 비해 훨씬 크다.
  - **낮은 가독성:** 태그가 많아질수록 사람이 읽기 불편하다.

### 다. YAML (YAML Ain't Markup Language)

사람이 읽고 쓰기 가장 편한 형태에 중점을 둔 데이터 포맷이다. 주로 애플리케이션의 설정(Configuration) 파일에서 압도적으로 많이 사용된다. (예: Docker, Kubernetes)

**예시:**

```yaml
# 사용자 정보
name: John Doe
age: 30
isActive: true
skills:
  - Java
  - Python
  - SQL
```

- **장점:**
  - **최상의 가독성:** 불필요한 괄호나 태그 없이, 들여쓰기만으로 구조를 표현하여 매우 간결하고 읽기 편하다.
  - **주석 지원:** 주석을 적극적으로 지원하여 설정 파일의 각 항목을 설명하기 용이하다.
  - **JSON 호환성:** YAML은 JSON의 상위 집합(Superset)이므로, 유효한 JSON 문서는 대부분 유효한 YAML 문서이기도 하다.
- **단점:**
  - **들여쓰기 민감성:** 공백 2칸, 4칸 등 들여쓰기에 따라 구조가 결정되므로, 사소한 공백 차이로 오류가 발생하기 쉽다.
  - **상대적으로 낮은 채택률:** API 데이터 교환보다는 설정 파일 용도로 주로 사용되어, JSON만큼 범용적이지는 않다.

---

## 3. 비교 요약 및 주요 사용 사례

| 구분          | JSON (JavaScript Object Notation) | XML (eXtensible Markup Language)                 | YAML (YAML Ain't Markup Language)             |
| :------------ | :-------------------------------- | :----------------------------------------------- | :-------------------------------------------- |
| **가독성**    | 높음                              | 낮음                                             | **매우 높음**                                 |
| **문법**      | `key: value` 쌍, 중괄호/대괄호    | 태그 기반 (`<tag></tag>`)                        | **들여쓰기 기반**                             |
| **주석**      | 미지원                            | **지원**                                         | **지원**                                      |
| **스키마**    | 미지원 (외부 도구로 검증)         | **지원 (DTD, XSD)**                              | 미지원                                        |
| **용량/속도** | **가볍고 빠름**                   | 무겁고 느림                                      | 가벼움                                        |
| **주요 용도** | **웹 API, AJAX, 모바일 앱 통신**  | 복잡한 기업 시스템, 정부/금융권, 레거시 SOAP API | **설정 파일 (Docker, K8s), 인프라 코드(IaC)** |
